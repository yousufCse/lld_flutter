# Flutter Flavor Setup Guide

A complete, production-ready guide to implementing multi-environment flavors (Dev, Staging, Production) in Flutter ‚Äî covering Android, iOS, app icons, and injectable dependency injection.

---

## Table of Contents

1. [Overview](#overview)
2. [Why Use Flavors?](#why-use-flavors)
3. [Project Structure](#project-structure)
4. [Step 1 ‚Äî Dependencies](#step-1--dependencies)
5. [Step 2 ‚Äî Environment Files](#step-2--environment-files)
6. [Step 3 ‚Äî Dart Configuration Layer](#step-3--dart-configuration-layer)
7. [Step 4 ‚Äî Entry Points](#step-4--entry-points)
8. [Step 5 ‚Äî Android Setup](#step-5--android-setup)
9. [Step 6 ‚Äî iOS Setup](#step-6--ios-setup)
10. [Step 7 ‚Äî App Icons with flutter_launcher_icons](#step-7--app-icons-with-flutter_launcher_icons)
11. [Step 8 ‚Äî Injectable Integration](#step-8--injectable-integration)
12. [Running & Building](#running--building)
13. [VS Code Launch Configuration](#vs-code-launch-configuration)
14. [Common Pitfalls & Fixes](#common-pitfalls--fixes)
15. [Best Practices](#best-practices)

---

## Overview

Flavors let you build multiple variants of your app from a single codebase ‚Äî each with its own API endpoints, app name, bundle ID, and icon. You can install dev, staging, and prod simultaneously on the same device.

### What You'll Have

- Three separate app variants: Dev, Staging, Production
- Different API endpoints, app names, and bundle identifiers
- Flavor-specific app icons on both Android and iOS
- Environment variables loaded from `.env.*` files
- Injectable dependency injection scoped per environment

---

## Why Use Flavors?

### Without Flavors

```dart
void main() {
  // Manually change this before every build ü§¶
  const apiUrl = 'https://dev-api.example.com';
  runApp(MyApp());
}
```

Problems: wrong config deployed to production, can't install both versions on one device, error-prone.

### With Flavors

```
flutter run -t lib/main_dev.dart --flavor dev      # always dev
flutter run -t lib/main_prod.dart --flavor prod    # always prod
```

The right config is locked to the right entry point. No manual changes.

---

## Project Structure

```
your_app/
‚îú‚îÄ‚îÄ flutter_launcher_icons-dev.yaml       # Icon config for dev
‚îú‚îÄ‚îÄ flutter_launcher_icons-staging.yaml   # Icon config for staging
‚îú‚îÄ‚îÄ flutter_launcher_icons-prod.yaml      # Icon config for prod
‚îú‚îÄ‚îÄ .env.dev
‚îú‚îÄ‚îÄ .env.staging
‚îú‚îÄ‚îÄ .env.prod
‚îÇ
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ main_dev.dart
‚îÇ   ‚îú‚îÄ‚îÄ main_staging.dart
‚îÇ   ‚îú‚îÄ‚îÄ main_prod.dart
‚îÇ   ‚îú‚îÄ‚îÄ main_common.dart
‚îÇ   ‚îú‚îÄ‚îÄ app.dart
‚îÇ   ‚îî‚îÄ‚îÄ core/
‚îÇ       ‚îî‚îÄ‚îÄ config/
‚îÇ           ‚îú‚îÄ‚îÄ flavor_config.dart
‚îÇ           ‚îú‚îÄ‚îÄ env_config.dart
‚îÇ           ‚îî‚îÄ‚îÄ app_config.dart
‚îÇ
‚îú‚îÄ‚îÄ android/
‚îÇ   ‚îî‚îÄ‚îÄ app/
‚îÇ       ‚îú‚îÄ‚îÄ build.gradle.kts              # Kotlin DSL (modern)
‚îÇ       ‚îî‚îÄ‚îÄ src/
‚îÇ           ‚îú‚îÄ‚îÄ main/AndroidManifest.xml
‚îÇ           ‚îú‚îÄ‚îÄ dev/res/mipmap-*/         # Generated by flutter_launcher_icons
‚îÇ           ‚îú‚îÄ‚îÄ staging/res/mipmap-*/
‚îÇ           ‚îî‚îÄ‚îÄ prod/res/mipmap-*/
‚îÇ
‚îî‚îÄ‚îÄ ios/
    ‚îú‚îÄ‚îÄ Flutter/
    ‚îÇ   ‚îú‚îÄ‚îÄ Debug.xcconfig
    ‚îÇ   ‚îî‚îÄ‚îÄ Release.xcconfig
    ‚îî‚îÄ‚îÄ Runner/
        ‚îú‚îÄ‚îÄ Info.plist
        ‚îî‚îÄ‚îÄ Assets.xcassets/
            ‚îú‚îÄ‚îÄ AppIcon.appiconset/
            ‚îú‚îÄ‚îÄ AppIcon-dev.appiconset/   # Generated by flutter_launcher_icons
            ‚îú‚îÄ‚îÄ AppIcon-staging.appiconset/
            ‚îî‚îÄ‚îÄ AppIcon-prod.appiconset/
```

---

## Step 1 ‚Äî Dependencies

### `pubspec.yaml`

```yaml
dependencies:
  flutter:
    sdk: flutter
  get_it: ^9.2.0
  injectable: ^2.7.1
  flutter_dotenv: ^6.0.0
  dio: ^5.9.1
  flutter_bloc: ^9.1.1

dev_dependencies:
  build_runner: ^2.10.5
  injectable_generator: ^2.12.0
  flutter_launcher_icons: ^0.14.4

flutter:
  assets:
    - .env.dev
    - .env.staging
    - .env.prod
```

```bash
flutter pub get
```

---

## Step 2 ‚Äî Environment Files

Create these in your project root. Add all three to `.gitignore`.

### `.env.dev`

```
APP_NAME=MyApp Dev
API_BASE_URL=https://dev-api.example.com
API_KEY=dev_key_here
ENABLE_LOGGING=true
```

### `.env.staging`

```
APP_NAME=MyApp Staging
API_BASE_URL=https://staging-api.example.com
API_KEY=staging_key_here
ENABLE_LOGGING=true
```

### `.env.prod`

```
APP_NAME=MyApp
API_BASE_URL=https://api.example.com
API_KEY=prod_key_here
ENABLE_LOGGING=false
```

### `.env.example` (commit this one)

```
APP_NAME=MyApp
API_BASE_URL=https://api.example.com
API_KEY=your_key_here
ENABLE_LOGGING=true
```

### `.gitignore`

```gitignore
.env.dev
.env.staging
.env.prod
# Keep the template
!.env.example
```

---

## Step 3 ‚Äî Dart Configuration Layer

### `lib/core/config/flavor_config.dart`

> **Note:** Dart 2.15+ enums already have a built-in `.name` getter. Do not redefine it.

```dart
enum Flavor {
  dev,
  staging,
  prod;

  bool get isDev => this == Flavor.dev;
  bool get isStaging => this == Flavor.staging;
  bool get isProd => this == Flavor.prod;

  String get displayName {
    switch (this) {
      case Flavor.dev:
        return 'Development';
      case Flavor.staging:
        return 'Staging';
      case Flavor.prod:
        return 'Production';
    }
  }

  String get envFile {
    switch (this) {
      case Flavor.dev:
        return '.env.dev';
      case Flavor.staging:
        return '.env.staging';
      case Flavor.prod:
        return '.env.prod';
    }
  }
}
```

### `lib/core/config/env_config.dart`

```dart
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'flavor_config.dart';

class EnvConfig {
  static Flavor? _flavor;
  static Flavor get flavor => _flavor!;

  static Future<void> initialize(Flavor flavor) async {
    _flavor = flavor;
    await dotenv.load(fileName: flavor.envFile);
  }

  static String get apiBaseUrl => dotenv.env['API_BASE_URL'] ?? '';
  static String get apiKey => dotenv.env['API_KEY'] ?? '';
  static String get appName => dotenv.env['APP_NAME'] ?? 'MyApp';
  static bool get enableLogging =>
      dotenv.env['ENABLE_LOGGING']?.toLowerCase() == 'true';
}
```

### `lib/core/config/app_config.dart`

```dart
import 'env_config.dart';
import 'flavor_config.dart';

class AppConfig {
  final Flavor flavor;
  final String appName;
  final String apiBaseUrl;
  final bool enableLogging;

  AppConfig._({
    required this.flavor,
    required this.appName,
    required this.apiBaseUrl,
    required this.enableLogging,
  });

  static AppConfig? _instance;
  static AppConfig get instance => _instance!;

  static Future<void> initialize(Flavor flavor) async {
    await EnvConfig.initialize(flavor);
    _instance = AppConfig._(
      flavor: flavor,
      appName: EnvConfig.appName,
      apiBaseUrl: EnvConfig.apiBaseUrl,
      enableLogging: EnvConfig.enableLogging,
    );
  }

  bool get isDev => flavor.isDev;
  bool get isStaging => flavor.isStaging;
  bool get isProd => flavor.isProd;
}
```

---

## Step 4 ‚Äî Entry Points

### `lib/main_dev.dart`

```dart
import 'core/config/app_config.dart';
import 'core/config/flavor_config.dart';
import 'main_common.dart';

Future<void> main() async {
  await AppConfig.initialize(Flavor.dev);
  await mainCommon(Flavor.dev);
}
```

### `lib/main_staging.dart`

```dart
import 'core/config/app_config.dart';
import 'core/config/flavor_config.dart';
import 'main_common.dart';

Future<void> main() async {
  await AppConfig.initialize(Flavor.staging);
  await mainCommon(Flavor.staging);
}
```

### `lib/main_prod.dart`

```dart
import 'core/config/app_config.dart';
import 'core/config/flavor_config.dart';
import 'main_common.dart';

Future<void> main() async {
  await AppConfig.initialize(Flavor.prod);
  await mainCommon(Flavor.prod);
}
```

### `lib/main_common.dart`

```dart
import 'package:flutter/material.dart';
import 'core/config/app_config.dart';
import 'core/config/flavor_config.dart';
import 'core/di/injectable_container.dart';
import 'app.dart';

Future<void> mainCommon(Flavor flavor) async {
  WidgetsFlutterBinding.ensureInitialized();
  await configureDependencies(flavor);
  runApp(const MyApp());
}
```

---

## Step 5 ‚Äî Android Setup

### Option A ‚Äî Kotlin DSL: `android/app/build.gradle.kts` (Modern, recommended)

New Flutter projects generate `.kts` files by default.

```kotlin
plugins {
    id("com.android.application")
    id("kotlin-android")
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.myapp"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
        }
    }

    defaultConfig {
        applicationId = "com.example.myapp"
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    // Flavor configuration
    flavorDimensions += "environment"

    productFlavors {
        create("dev") {
            dimension = "environment"
            applicationIdSuffix = ".dev"
            versionNameSuffix = "-dev"
            resValue("string", "app_name", "MyApp Dev")
        }
        create("staging") {
            dimension = "environment"
            applicationIdSuffix = ".staging"
            versionNameSuffix = "-staging"
            resValue("string", "app_name", "MyApp Staging")
        }
        create("prod") {
            dimension = "environment"
            // No suffix ‚Äî prod uses the base applicationId
            resValue("string", "app_name", "MyApp")
        }
    }

    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("debug") // Replace with real signing
        }
    }
}

flutter {
    source = "../.."
}
```

### Option B ‚Äî Groovy DSL: `android/app/build.gradle` (Legacy projects)

Older projects use the Groovy DSL. The syntax is slightly different:

```groovy
plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'dev.flutter.flutter-gradle-plugin'
}

android {
    namespace "com.example.myapp"
    compileSdk flutter.compileSdkVersion
    ndkVersion flutter.ndkVersion

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    defaultConfig {
        applicationId "com.example.myapp"
        minSdk flutter.minSdkVersion
        targetSdk flutter.targetSdkVersion
        versionCode flutter.versionCode
        versionName flutter.versionName
    }

    // Flavor configuration
    flavorDimensions "environment"

    productFlavors {
        dev {
            dimension "environment"
            applicationIdSuffix ".dev"
            versionNameSuffix "-dev"
            resValue "string", "app_name", "MyApp Dev"
        }
        staging {
            dimension "environment"
            applicationIdSuffix ".staging"
            versionNameSuffix "-staging"
            resValue "string", "app_name", "MyApp Staging"
        }
        prod {
            dimension "environment"
            resValue "string", "app_name", "MyApp"
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.debug // Replace with real signing
        }
    }
}

flutter {
    source "../.."
}
```

### `android/app/src/main/AndroidManifest.xml`

Use `@string/app_name` so each flavor picks up its own label:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.INTERNET"/>

    <application
        android:label="@string/app_name"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>

    </application>
</manifest>
```

---

## Step 6 ‚Äî iOS Setup

### Step 6.1 ‚Äî Open Xcode

Always open the workspace, not the project:

```bash
open ios/Runner.xcworkspace
```

### Step 6.2 ‚Äî Create Build Configurations

1. In Xcode, select the **Runner** project (not the target) in the left navigator
2. Go to the **Info** tab
3. Under **Configurations**, you'll see Debug, Release, and Profile
4. Duplicate each to create flavor variants:
   - Duplicate **Debug** ‚Üí rename to **Debug-dev**
   - Duplicate **Debug** ‚Üí rename to **Debug-staging**
   - Duplicate **Debug** ‚Üí rename to **Debug-prod**
   - Duplicate **Release** ‚Üí rename to **Release-dev**
   - Duplicate **Release** ‚Üí rename to **Release-staging**
   - Duplicate **Release** ‚Üí rename to **Release-prod**
   - Duplicate **Profile** ‚Üí rename to **Profile-dev**
   - Duplicate **Profile** ‚Üí rename to **Profile-staging**
   - Duplicate **Profile** ‚Üí rename to **Profile-prod**

> Delete the original Debug/Release/Profile if you won't use them, or keep them as fallbacks.

### Step 6.3 ‚Äî Create Schemes

1. Go to **Product ‚Üí Scheme ‚Üí Manage Schemes**
2. Click **+**, select **Runner** as the target
3. Create three schemes named exactly: `dev`, `staging`, `prod`

For each scheme, set the build configurations:

| Action | dev scheme | staging scheme | prod scheme |
|--------|-----------|----------------|-------------|
| Run | Debug-dev | Debug-staging | Debug-prod |
| Test | Debug-dev | Debug-staging | Debug-prod |
| Profile | Profile-dev | Profile-staging | Profile-prod |
| Analyze | Debug-dev | Debug-staging | Debug-prod |
| Archive | Release-dev | Release-staging | Release-prod |

Make sure **Shared** is checked for each scheme so they are committed to version control.

### Step 6.4 ‚Äî Configure Build Settings

Select **Runner** target ‚Üí **Build Settings** ‚Üí set for each configuration:

**Product Bundle Identifier** (search: `PRODUCT_BUNDLE_IDENTIFIER`):

| Configuration | Value |
|---|---|
| Debug-dev, Release-dev, Profile-dev | `com.example.myapp.dev` |
| Debug-staging, Release-staging, Profile-staging | `com.example.myapp.staging` |
| Debug-prod, Release-prod, Profile-prod | `com.example.myapp` |

**App Display Name** ‚Äî add a user-defined setting named `APP_DISPLAY_NAME`:

| Configuration | Value |
|---|---|
| *-dev | `MyApp Dev` |
| *-staging | `MyApp Staging` |
| *-prod | `MyApp` |

### Step 6.5 ‚Äî Update `ios/Runner/Info.plist`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDisplayName</key>
    <string>$(APP_DISPLAY_NAME)</string>

    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>

    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>

    <key>CFBundleShortVersionString</key>
    <string>$(FLUTTER_BUILD_NAME)</string>

    <key>CFBundleVersion</key>
    <string>$(FLUTTER_BUILD_NUMBER)</string>

    <!-- other keys unchanged -->
</dict>
</plist>
```

---

## Step 7 ‚Äî App Icons with flutter_launcher_icons

`flutter_launcher_icons` supports flavors via separate config files named `flutter_launcher_icons-<flavor>.yaml` in the project root.

### Step 7.1 ‚Äî Prepare Icon Images

Place your source images in `assets/images/`:

```
assets/images/
‚îú‚îÄ‚îÄ app-icon-dev.png      # 1024x1024, transparent background OK
‚îú‚îÄ‚îÄ app-icon-staging.png
‚îî‚îÄ‚îÄ app-icon-prod.png
```

### Step 7.2 ‚Äî Create Config Files

#### `flutter_launcher_icons-dev.yaml`

```yaml
flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/images/app-icon-dev.png"
  min_sdk_android: 21
  adaptive_icon_background: "#FFFFFF"
  adaptive_icon_foreground: "assets/images/app-icon-dev.png"
```

#### `flutter_launcher_icons-staging.yaml`

```yaml
flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/images/app-icon-staging.png"
  min_sdk_android: 21
  adaptive_icon_background: "#FFFFFF"
  adaptive_icon_foreground: "assets/images/app-icon-staging.png"
```

#### `flutter_launcher_icons-prod.yaml`

```yaml
flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/images/app-icon-prod.png"
  min_sdk_android: 21
  adaptive_icon_background: "#FFFFFF"
  adaptive_icon_foreground: "assets/images/app-icon-prod.png"
```

### Step 7.3 ‚Äî Generate Icons

```bash
dart run flutter_launcher_icons
```

This detects all three flavor files and generates:

- **Android:** `android/app/src/dev/res/mipmap-*/`, `src/staging/res/...`, `src/prod/res/...`
- **iOS:** `ios/Runner/Assets.xcassets/AppIcon-dev.appiconset/`, `AppIcon-staging.appiconset/`, `AppIcon-prod.appiconset/`

### Step 7.4 ‚Äî Wire iOS Icons to Build Configurations (CRITICAL)

> **This step is the most commonly missed.** The generator creates the icon sets but does NOT automatically update Xcode to use them. Without this step, iOS always shows the default Flutter icon regardless of flavor.

In Xcode, go to **Runner target ‚Üí Build Settings**, search for **"Primary App Icon Set Name"** (`ASSETCATALOG_COMPILER_APPICON_NAME`), and set:

| Configuration | Value |
|---|---|
| Debug-dev, Release-dev, Profile-dev | `AppIcon-dev` |
| Debug-staging, Release-staging, Profile-staging | `AppIcon-staging` |
| Debug-prod, Release-prod, Profile-prod | `AppIcon-prod` |

Alternatively, edit `ios/Runner.xcodeproj/project.pbxproj` directly. Find every block with `APP_DISPLAY_NAME = "MyApp Dev"` and change:

```
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
```
to:
```
ASSETCATALOG_COMPILER_APPICON_NAME = "AppIcon-dev";
```

Do the same for staging and prod blocks. There will be 3 occurrences per flavor (Debug, Release, Profile).

---

## Step 8 ‚Äî Injectable Integration

### `lib/core/di/injectable_container.dart`

```dart
import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import '../config/flavor_config.dart';
import 'injectable_container.config.dart';

final getIt = GetIt.instance;

@InjectableInit(
  initializerName: 'init',
  preferRelativeImports: true,
  asExtension: true,
)
Future<void> configureDependencies(Flavor flavor) async {
  await getIt.init(environment: flavor.name);
}
```

### `lib/core/config/injectable_environments.dart`

```dart
import 'package:injectable/injectable.dart';

const dev = Environment('dev');
const staging = Environment('staging');
const prod = Environment('prod');
```

### Environment-Specific Module Example

```dart
import 'package:injectable/injectable.dart';
import '../config/injectable_environments.dart';

abstract class LoggerService {
  void log(String message);
}

@dev
@LazySingleton(as: LoggerService)
class DevLogger implements LoggerService {
  @override
  void log(String message) => print('[DEV] $message');
}

@staging
@LazySingleton(as: LoggerService)
class StagingLogger implements LoggerService {
  @override
  void log(String message) => print('[STAGING] $message');
}

@prod
@LazySingleton(as: LoggerService)
class ProdLogger implements LoggerService {
  @override
  void log(String message) {
    // Send to Sentry / Crashlytics only
  }
}
```

### Generate DI Code

```bash
dart run build_runner build --delete-conflicting-outputs
```

> **Note:** Use `dart run`, not the deprecated `flutter pub run`.

---

## Running & Building

### Run

```bash
flutter run -t lib/main_dev.dart --flavor dev
flutter run -t lib/main_staging.dart --flavor staging
flutter run -t lib/main_prod.dart --flavor prod
```

### Build APK (Android)

```bash
flutter build apk -t lib/main_dev.dart --flavor dev
flutter build apk -t lib/main_staging.dart --flavor staging
flutter build apk -t lib/main_prod.dart --flavor prod --release
```

### Build App Bundle for Play Store

```bash
flutter build appbundle -t lib/main_prod.dart --flavor prod --release
```

### Build iOS

```bash
flutter build ios -t lib/main_dev.dart --flavor dev
flutter build ios -t lib/main_staging.dart --flavor staging
flutter build ipa -t lib/main_prod.dart --flavor prod --release
```

---

## VS Code Launch Configuration

Create `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Dev",
      "request": "launch",
      "type": "dart",
      "program": "lib/main_dev.dart",
      "args": ["--flavor", "dev"]
    },
    {
      "name": "Staging",
      "request": "launch",
      "type": "dart",
      "program": "lib/main_staging.dart",
      "args": ["--flavor", "staging"]
    },
    {
      "name": "Production",
      "request": "launch",
      "type": "dart",
      "program": "lib/main_prod.dart",
      "args": ["--flavor", "prod"]
    }
  ]
}
```

---

## Common Pitfalls & Fixes

### 1. iOS always shows the default Flutter icon (most common)

**Cause:** `ASSETCATALOG_COMPILER_APPICON_NAME` is set to `AppIcon` for all configurations. `flutter_launcher_icons` generates the flavor icon sets but does not update this Xcode build setting.

**Fix:** Manually set the icon set name per configuration (see [Step 7.4](#step-74--wire-ios-icons-to-build-configurations-critical)).

Verify by searching in `project.pbxproj`:
```
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;   ‚Üê wrong for flavor builds
ASSETCATALOG_COMPILER_APPICON_NAME = "AppIcon-dev";  ‚Üê correct
```

---

### 2. `Podfile` error ‚Äî `Generated.xcconfig` must exist

```
[!] Invalid `Podfile` file: .../Flutter/Generated.xcconfig must exist.
```

**Cause:** `flutter pub get` has not been run. This file is generated by Flutter, not committed to git.

**Fix:**
```bash
flutter pub get
cd ios && pod install && cd ..
```

---

### 3. App name not changing on iOS

**Cause:** `Info.plist` still has a hardcoded string for `CFBundleDisplayName` instead of `$(APP_DISPLAY_NAME)`.

**Fix:** Make sure `Info.plist` uses the variable:
```xml
<key>CFBundleDisplayName</key>
<string>$(APP_DISPLAY_NAME)</string>
```

And that `APP_DISPLAY_NAME` is defined in each build configuration's settings in Xcode.

---

### 4. Wrong app icon appearing after re-running

**Cause:** iOS simulators and devices aggressively cache app icons.

**Fix:** Delete the app from the simulator/device, then reinstall:
```bash
flutter clean
flutter run -t lib/main_dev.dart --flavor dev
```

---

### 5. `flutter_launcher_icons` only generates for one flavor

**Cause:** Running the tool with a flavor-specific flag when the files should be auto-detected.

**Fix:** Just run without flags ‚Äî the package auto-detects all `flutter_launcher_icons-*.yaml` files:
```bash
dart run flutter_launcher_icons
```

---

### 6. Android icons not showing (using adaptive icons)

**Cause:** The `adaptive_icon_foreground` image has padding issues, or `min_sdk_android` is below 21.

**Fix:** Ensure `min_sdk_android: 21` is set and your foreground image has a safe zone (the icon content should stay within the inner 66% of the image).

---

### 7. `Flavor.name` conflict in Dart

**Cause:** Dart 2.15+ enums have a built-in `.name` getter. Defining your own `name` getter on a Flavor enum causes a compile error.

**Fix:** Remove any custom `name` getter from your enum ‚Äî use the built-in one. `Flavor.dev.name` already returns `"dev"`.

---

### 8. Scheme not found when running from CLI

```
Could not find scheme 'dev'.
```

**Cause:** The scheme exists in Xcode but **Shared** was not checked, so it was not committed to the repo.

**Fix:** In Xcode ‚Üí **Product ‚Üí Scheme ‚Üí Manage Schemes**, check the **Shared** checkbox for each flavor scheme.

---

### 9. `dart run build_runner` not found

**Cause:** Using the deprecated `flutter pub run` command.

**Fix:** Always use:
```bash
dart run build_runner build --delete-conflicting-outputs
```

---

### 10. Both Android and iOS fail with "flavor not found"

**Cause:** Always specify both `--flavor` and `-t` together. Omitting either causes a mismatch.

```bash
# Correct
flutter run -t lib/main_dev.dart --flavor dev

# Wrong ‚Äî Flutter picks a default entry point that may not match
flutter run --flavor dev
```

---

## Best Practices

### Security

- Never commit `.env.dev`, `.env.staging`, `.env.prod`
- Commit only `.env.example` as a template
- Inject production secrets via CI/CD environment variables

### Naming

- Flavor names must be **lowercase** and match exactly between Android, iOS schemes, and the `--flavor` flag
- Common convention: `dev`, `staging`, `prod`

### Visual Differentiation

- Use different icon designs per flavor (e.g., a badge or different color scheme) so testers can instantly tell environments apart
- Consider showing an environment banner in non-production builds:

```dart
// In app.dart
builder: (context, child) {
  if (!AppConfig.instance.isProd) {
    return Banner(
      message: AppConfig.instance.flavor.name.toUpperCase(),
      location: BannerLocation.topEnd,
      color: AppConfig.instance.isDev ? Colors.green : Colors.orange,
      child: child!,
    );
  }
  return child!;
},
```

### Code Generation

Run after any change to DI annotations or annotated model classes:

```bash
dart run build_runner build --delete-conflicting-outputs
```

### CI/CD

Create the env file from a secret before building:

```yaml
# GitHub Actions example
- name: Create .env.prod
  run: echo "${{ secrets.ENV_PROD }}" > .env.prod

- name: Build
  run: flutter build appbundle -t lib/main_prod.dart --flavor prod --release
```

---

## Resources

- [Flutter Flavors Documentation](https://docs.flutter.dev/deployment/flavors)
- [flutter_launcher_icons on pub.dev](https://pub.dev/packages/flutter_launcher_icons)
- [injectable on pub.dev](https://pub.dev/packages/injectable)
- [flutter_dotenv on pub.dev](https://pub.dev/packages/flutter_dotenv)

---

**Author:** Md. Yousuf Ali
**Document Version:** 2.0
**Last Updated:** February 2026
